using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Configuration;
using System.Threading.Tasks;
using System.IO;
using Ingeniux.Runtime.RuntimeAuth;
using Ingeniux.Runtime.Models;

namespace Ingeniux.Runtime.Controllers
{
	[SessionState(System.Web.SessionState.SessionStateBehavior.ReadOnly)]
	public class AssetAsyncController : AsyncController
	{
		public AuthenticationManager Authman;
		bool isPreviewRequest = false;
		public string AssetBasePath { get; protected set; }
		protected override void Initialize(System.Web.Routing.RequestContext requestContext)
		{
			base.Initialize(requestContext);

			string sitePath = ConfigurationManager.AppSettings["PageFilesLocation"];

			isPreviewRequest = requestContext.HttpContext.Request.QueryString["_previewAsset_"] == "true";

			//check if the asset followed with querystring "previewAsset"
			AssetBasePath = (isPreviewRequest) ?
				ConfigurationManager.AppSettings["DesignTimeAssetsLocation"] :
				sitePath;

			if (string.IsNullOrEmpty(AssetBasePath))
				AssetBasePath = sitePath;

			Authman = AuthenticationManager.Get(sitePath);
		}

		private bool changed(DateTime modificationDate)
		{
			string modifiedHeaderValue = Request.Headers["If-Modified-Since"]
				.ToNullOrEmptyHelper()
				.Return(Request.Headers["If-Range"]);

			if (string.IsNullOrWhiteSpace(modifiedHeaderValue))
				return true;

			var modifiedSince = DateTime.Parse(modifiedHeaderValue).ToLocalTime();
			TimeSpan modifiedDuration = (modificationDate - modifiedSince);

			//remove the second discrepency. header value is only accurate to seconds.
			return modifiedDuration.TotalSeconds > 1;
		}

		public async Task<ActionResult> Get()
		{
			string path = HttpUtility.UrlDecode(Request.GetRelativePath());

			//if it is going to ICE images, use a different system, get image content from resource
			if (path.ToLowerInvariant().EndsWith("images/_ice_/play.png"))
			{
				string ext = Path.GetExtension(path);
				string mimeType = MIMEAssistant.GetMIMEType("png");

				var image = Properties.Resources.play;

				MemoryStream ms = new MemoryStream();
				image.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
				ms.Position = 0;

				return File(ms, mimeType);
			}
			else
			{
				path = path.Contains("assets/") ? path.SubstringAfter("assets/") : path;
				string assetPath = Path.Combine(AssetBasePath, path.TrimStart('/').Replace("/", @"\"));

				//block any access in settings folder
				string settingsFolder = Path.Combine(AssetBasePath, "settings").ToLowerInvariant() + @"\";
				if (assetPath.ToLowerInvariant().StartsWith(settingsFolder))
				{
					throw new HttpException((int)AssetRequestState.Forbidden, Ingeniux.Runtime.Properties.Resources.AccessToDynamicSiteServerMetaDataIsForbidd);
				}

				if (!System.IO.File.Exists(assetPath))
					throw new HttpException(404, Ingeniux.Runtime.Properties.Resources.AssetDoesnTExist);

				DateTime lastWriteTime = System.IO.File.GetLastWriteTime(assetPath);

				if (!changed(lastWriteTime))
					return new HttpStatusCodeResult(304);

				string ext = Path.GetExtension(assetPath).TrimStart('.');

				string mimeType = MIMEAssistant.GetMIMEType(ext);

				if (path.StartsWith("documents/") || mimeType == MIMEAssistant.DEFAULT_MIME_TYPE)
					Response.AddHeader("Content-Disposition", "attachment");

				string thisUrl = Request.Url.AbsoluteUri;

				if (!isPreviewRequest)
				{
					if (Authman.IsForbiddenAsset(path) || Authman.IsProtectedAsset(path))
					{
						setNoCache();
					}
					else
					{
						Response.Cache.SetCacheability(HttpCacheability.Public);
						Response.Cache.SetExpires(DateTime.MaxValue);
						Response.CacheControl = "public";
						Response.Cache.SetLastModified(System.IO.File.GetLastWriteTime(assetPath));
					}

					//when runtime request, check protected and forbidden folder
					AssetRequestState stateCheck = Authman.CheckAssetAccessiblility(path, Request);
					if (stateCheck == AssetRequestState.Forbidden)
					{
						string forbiddenResponsePagePath = AuthenticationManager.Settings.ForbiddenFoldersResponsePage;

						//path is blocked, go to forbidden response page
						if (!string.IsNullOrWhiteSpace(forbiddenResponsePagePath))
						{
							if (!forbiddenResponsePagePath.EndsWith(".xml") || !forbiddenResponsePagePath.SubstringBefore(".", false, true).IsXId())
							{

								string fullRedirPath = forbiddenResponsePagePath.ToAbsoluteUrl();
								fullRedirPath += fullRedirPath.Contains("?") ? "&" : "?";
								fullRedirPath += "blockedPath=" + HttpUtility.UrlEncode(HttpUtility.UrlEncode(thisUrl));

								return Redirect(fullRedirPath);
							}
							else
							{
								//if the setting is standar xid.xml, then use more friendly path rewrite
								return rewriteToCmsPath(
									forbiddenResponsePagePath.SubstringBefore(".", false, true),
									new Dictionary<string, string> {
										{"blockedPath", thisUrl}});
							}
						}
						else
							throw new HttpException((int)stateCheck, Ingeniux.Runtime.Properties.Resources.AccessToAssetIsForbidden);
					}

					if (stateCheck == AssetRequestState.Unauthorized)
					{
						string loginPagePath = Authman.LoginPath;
						if (!string.IsNullOrWhiteSpace(loginPagePath))
						{
							string loginPathUrl = loginPagePath.ToAbsoluteUrl();
							loginPathUrl += loginPathUrl.Contains("?") ? "&" : "?";
							loginPathUrl += AuthenticationManager.Settings.RedirectionQueryStringName + "=" + Uri.EscapeDataString(Uri.EscapeDataString(thisUrl));
							return RedirectPermanent(loginPathUrl);
						}
						else
							throw new HttpException((int)stateCheck, Ingeniux.Runtime.Properties.Resources.AccessToAssetIsNotAuthorized);
					}

					//use download manager if is protected asset, this way we can use the download page
					if (!string.IsNullOrWhiteSpace(AuthenticationManager.Settings.BinaryDownloadPage) && Authman.IsProtectedAsset(path))
					{
						DownloadManager downloadsMan = Authman.DownloadsManager;
						string downloadPageId;
						Dictionary<string, string> queryStrings = new Dictionary<string, string>();
						bool presentDownloadPage = downloadsMan.ProcessProtectedDownload(Request.RequestContext.HttpContext,
							out queryStrings, out downloadPageId);

						if (!presentDownloadPage)
						{
							Response.AddHeader("Content-Disposition", "attachment");
							
							return File(assetPath, mimeType);
						}

						return rewriteToCmsPath(downloadPageId, queryStrings);
					}
				}

				return File(assetPath, mimeType);
			}
		}

		private ActionResult rewriteToCmsPath(string pageId,
			Dictionary<string, string> queryStrings)
		{
			//present download page that hosts this download
			CMSPageDefaultController pageController = initPageController();

			//get page by id
			ICMSRequest interceptPage = pageController._PageFactory.GetPage(Request, pageId);
			//add 3 query strings

			foreach (var pair in queryStrings)
				(interceptPage as ICMSEnvironment).QueryString.Add(pair.Key, pair.Value);

			//redo page content to reserialize the querystrings
			(interceptPage as CMSPageRequest).GetPageContent();

			setNoCache();

			return pageController.viewOrXsltFallback(interceptPage as CMSPageRequest);
		}

		private void setNoCache()
		{
			//make sure no caching of this page
			Response.Cache.SetCacheability(HttpCacheability.NoCache);
			Response.Cache.SetNoStore();
			Response.Expires = 0;
		}

		/// <summary>
		/// Handle 404 exception and redirect it to the 404 error page, and fallback to NotFoundError view
		/// </summary>
		/// <param name="filterContext"></param>
		protected override void OnException(ExceptionContext filterContext)
		{
			//handle 404 exception
			if (filterContext.Exception is HttpException)
			{
				HttpException httpException = filterContext.Exception as HttpException;
				if (httpException.GetHttpCode() == 404)
				{
					CMSPageDefaultController pageController = initPageController();
					pageController.exception(filterContext);
				}
			}
			base.OnException(filterContext);
		}

		private CMSPageDefaultController initPageController()
		{
			CMSPageDefaultController pageController = new CMSPageDefaultController();
			pageController.init(this.Request.RequestContext);
			//change route data, otherwise mvc 404 page will not have view applied, since it will not be able to load view
			pageController.ControllerContext.RouteData.Values["controller"] = "CMSPageDefault";
			pageController.ControllerContext.RouteData.Values["action"] = "Index";
			return pageController;
		}
	}
}